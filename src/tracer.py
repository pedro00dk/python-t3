from protobuf import snapshot_pb2, tracer_pb2
import sys
import types
import scope
from inspector import exceptionMessage, Inspector
from hooks import HookedInput, HookedPrint


class Tracer:
    """
    Traces python source and analyses its state after each instruction.
    """

    def __init__(self, trace: tracer_pb2.Trace):
        self._filename = '<script>'
        self._source = trace.source
        self._input = trace.input.splitlines()
        self._steps = trace.steps

        self._inspector = Inspector()
        self._result = tracer_pb2.Result()

        self._current_step = 0
        self._input_index = 0
        self._missing_input = False
        self._exec_call_frame = None  # base frame (exec function call)
        self._print_cache = []

    def run(self):
        globals = scope.sandbox_globals(self._filename)
        globals['__builtins__']['input'] = HookedInput(self._input_hook)
        globals['__builtins__']['print'] = HookedPrint(self._print_hook)

        try:
            compiled = compile(self._source, self._filename, 'exec')
            sys.settrace(self._trace)
            exec(compiled, globals)
        except Exception as e:
            if not isinstance(e, UserWarning):
                # UserWarning are generated by the tracer to stop (the only way)
                self._result.steps.add().threw.exception.CopyFrom(exceptionMessage(e, remove_lines=(1,)))
        finally:
            sys.settrace(None)

        return self._result

    def _trace(self, frame: types.FrameType, event: str, args):
        if not frame.f_code.co_filename == self._filename or not event in {'call', 'line', 'exception', 'return'}:
            return self._trace
        if self._exec_call_frame is None:
            self._exec_call_frame = frame.f_back
        self._current_step += 1
        if self._current_step > self._steps:
            self._result.steps.add().threw.cause = f'maximum steps: {self._steps}'
            raise UserWarning()
        if self._missing_input:
            self._result.steps.add().threw.cause = 'not enough input'
            raise UserWarning()

        step = self._result.steps.add(
            snapshot=self._inspector.inspect(frame, event, args, self._exec_call_frame),
            prints=self._print_cache
        )
        self._print_cache = []

        return self._trace

    def _input_hook(self, prompt: str):
        self._print_cache.append(prompt)
        if self._input_index < len(self._input):
            self._input_index += 1
            return self._input[self._input_index - 1]
        self._missing_input = True
        return None

    def _print_hook(self, text: str):
        self._print_cache.append(text)
