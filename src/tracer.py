import sys
import types
import scope
import traceback
from inspector import Inspector
from hooks import HookedInput, HookedPrint


def dump_exception(exception: Exception, with_traceback: types.TracebackType = None, remove_lines: tuple = ()):
    """
    Builds exception dicts from objects.
    """
    formatted_traceback = traceback.format_exception(
        type(exception),
        exception,
        exception.__traceback__ if not with_traceback else with_traceback
    )

    return {
        'type': type(exception).__name__,
        'traceback': [line for i, line in enumerate(formatted_traceback) if i not in remove_lines]
    }


class TracerStopException(Exception):
    """
    Exception used to stop the tracer during the inspection process.
    """
    pass


class Tracer:
    """
    Traces python source and analyses its state after each instruction.
    """

    def __init__(self, trace: dict):
        self._filename = '<script>'
        self._source = trace['source']
        self._input = trace['input'].splitlines()
        self._steps = trace['steps']

        self._inspector = Inspector()
        self._result = None

        self._current_step = 0
        self._input_index = 0
        self._missing_input = False
        self._exec_call_frame = None  # base frame (exec function call)
        self._print_cache = []

    def run(self):
        self._result = {"steps": []}
        globals = scope.sandbox_globals(self._filename)
        globals['__builtins__']['input'] = HookedInput(self._input_hook)
        globals['__builtins__']['print'] = HookedPrint(self._print_hook)

        try:
            compiled = compile(self._source, self._filename, 'exec')
            sys.settrace(self._trace)
            exec(compiled, globals)
        except TracerStopException as e:
            # UserWarning is generated by the tracer to stop (the only way to stop it)
            # These exceptions are not caused by the application, hence they use the cause field instead of exception
            self._result["steps"].append({'threw': {'cause': str(e)}})
            pass
        except Exception as e:
            # Exceptions that caused the source program stop or the tracer program
            # They can be clearly distincted by their tracebacks
            self._result["steps"].append({'threw': {'exception': dump_exception(e, remove_lines=(1,))}})
        finally:
            sys.settrace(None)

        return self._result

    def _trace(self, frame: types.FrameType, event: str, args):
        if not frame.f_code.co_filename == self._filename or not event in {'call', 'line', 'exception', 'return'}:
            return self._trace
        if self._exec_call_frame is None:
            self._exec_call_frame = frame.f_back
        self._current_step += 1
        if self._current_step > self._steps:
            raise TracerStopException(f'reached maximum step: {self._steps}')
        if self._missing_input:
            raise TracerStopException('input not enough')

        self._result["steps"].append({
            'snapshot': self._inspector.inspect(frame, event, args, self._exec_call_frame),
            'prints': self._print_cache
        })
        self._print_cache = []

        return self._trace

    def _input_hook(self, prompt: str):
        self._print_cache.append(prompt)
        if self._input_index < len(self._input):
            self._input_index += 1
            return self._input[self._input_index - 1]
        self._missing_input = True
        return None

    def _print_hook(self, text: str):
        self._print_cache.append(text)
